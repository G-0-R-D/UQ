
import os

def build(ENV):

	'' # TODO move SnapCCompiler into here, add all the python stuff, then once we know what is python-only we'll move it into the python specific compiler...

	SnapNode = ENV.SnapNode

	class SnapProgrammingLanguageCompiler(SnapNode):

		__slots__ = []

		# TODO std operations included here?
		def visit_x(self, N):
			''

		def visit_for(self, N):
			# https://github.com/python/cpython/blob/d93605de7232da5e6a182fd1d5c220639e900159/Python/compile.c#L2651

			start,cleanup,end = {},{},{}
			
			# TODO self.push_fblock(c, NODE, start, end) ?

			# self.preprocess_element(NODE['in'])

			# TODO ADDOP GET_ITER? # TODO accesses NODE['target']?

			# TODO compiler_use_next_block(start)

			# TODO ADDOP_JREL(FOR_ITER, cleanup)

			# self.preprocess_element(NODE['body'])

			# TODO ADDOP_JABS(JUMP_ABSOLUTE, start)

			# compiler_use_next_block(cleanup)

			# compiler_pop_fblock(NODE, start)

			# for stmt in NODE['else']:
			#	self.preprocess_element(stmt)

			# compiler_use_next_block(end)
			
			"""
			basicblock *start, *cleanup, *end;

			start = compiler_new_block(c);
			cleanup = compiler_new_block(c);
			end = compiler_new_block(c);
			if (start == NULL || end == NULL || cleanup == NULL)
				return 0;

			if (!compiler_push_fblock(c, FOR_LOOP, start, end))
				return 0;

			VISIT(c, expr, s->v.For.iter);
			ADDOP(c, GET_ITER);
			compiler_use_next_block(c, start);
			ADDOP_JREL(c, FOR_ITER, cleanup);
			VISIT(c, expr, s->v.For.target);
			VISIT_SEQ(c, stmt, s->v.For.body);
			ADDOP_JABS(c, JUMP_ABSOLUTE, start);
			compiler_use_next_block(c, cleanup);

			compiler_pop_fblock(c, FOR_LOOP, start);

			VISIT_SEQ(c, stmt, s->v.For.orelse);
			compiler_use_next_block(c, end);
			return 1;
			"""
			raise NotImplementedError(repr(N['__type__']))

		def encode_mainfile(self):
			# self is SnapProject() instance?
			#	-- project determines which module to 'run directly' ie. the main file, and which modules to include...
			# TODO this is basically just the includes, the init of ENV (pass sys.argv to ENV too), and then evaluate until evaluation stops and return status, cleanup anything needing to cleanup... (the operations if any should all be implemented in snap.h lib)
			#	TODO modules need to be 'built' into ENV modules, but when imported by other modules (so the import statement operation will 'call' the module that is imported, but the module is initialized (import and register the mainbody function to run on import) here

			'use project settings to determine where to put it'


			INDENT = '\t'

			yield '/* this file was automatically generated by {} */\n\n'.format(os.path.basename(__file__))

			#yield '#ifdef __cplusplus\n'
			#yield 'extern "C" {\n'
			#yield '#endif\n\n'

			#{GLOBAL_DEFINES}

			#{INCLUDES} TODO should we include all modules, and make import() just an ENV operation?
			#yield '#include "snap_core.h"\n\n'

			yield '#include "snap.h"\n\n'

			yield '/* TODO include each imported module... (modules will be either shared libraries on their own, or just the header files for a static build...) */\n\n'

			yield 'int main(int argc, char **argv){\n\n'

			yield INDENT + '/* TODO init ENV (put argv into env a SnapObject str type, split on whitespace (shlex?))*/\n\n'

			yield INDENT + '/* TODO call main module BUILD() */\n\n'

			yield INDENT + '/* TODO start evaluating ops in ENV.__stack__ until program is complete */\n\n'

			yield '\treturn 0;\n'
			yield '}\n\n'

			#yield '#ifdef __cplusplus\n'
			#yield '}\n'
			#yield '#endif\n'

		# TODO 
		def encode_module(self):
			'use the pre-processed info, yield the module text'
			# TODO:CONCEPT:
			"""
			each snap module will be compiled as a stand-alone shared library representing the module, with a single function of
			ModuleName_MAINBODY(ENV), which can be called to 'load' the code for the module (which should then be run by the calling ENV context)
			-- this means there is no need for #includes!  -- the #includes would be done by the main module, which includes each of the modules and initializes them...

			the operators are just c functions the perform their action on the ENV stack, and they may possibly have arguments?
			"""

			INDENT = '\t'

			MODULE_NAME = '<MODULE_NAME:TODO>'
			MODULE_HEADER_GUARD_NAME = '__<MODULE_HEADER_GUARD_NAME:TODO>_H__'

			yield '#ifndef ' + MODULE_HEADER_GUARD_NAME + '\n'
			yield '#define ' + MODULE_HEADER_GUARD_NAME + '\n\n'

			yield 'void ' + '__' + MODULE_NAME + '_BUILD(SnapEnv* ENV){\n\n'

			yield INDENT + 'if (ENV == NULL){\n'
			yield INDENT*2 + '/*print error? TODO*/\n'
			yield INDENT*2 + 'return NULL;\n'
			yield INDENT + '}\n\n'

			yield INDENT + '/* TODO: realloc ENV.stack for the new commands... we realloc and then assign the opcodes: */\n\n'

			oplist = ['{.op=<OP>, .msg=<MSG?>}'] # TODO get preprocessed op list
			for idx,op in enumerate(oplist):
				yield INDENT + 'ENV->__stack__[' + str(idx) + '] = ' + op + ';\n'

			yield '}\n\n'

			yield '#endif ' + MODULE_HEADER_GUARD_NAME + '\n'

	ENV.SnapProgrammingLanguageCompiler = SnapProgrammingLanguageCompiler

def main(ENV):

	SnapProgrammingLanguageCompiler = ENV.SnapProgrammingLanguageCompiler

	c = SnapProgrammingLanguageCompiler()

	for line in c.encode_module():
		print(line, end='')

	for line in c.encode_mainfile():
		print(line, end='')

if __name__ == '__main__':

	from snap.SnapEnv import SnapEnv
	main(SnapEnv())

