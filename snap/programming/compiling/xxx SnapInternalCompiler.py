
# this compiler is for making backend c components, outside of the opcode system...
#	-- primarily useful for being able to implement the backend types in python code and just compile them into c instead of typing them out in c!  (also makes it easier to make changes to the backend, which is happening a lot right now)

# TODO move SnapCCompiler.py code to here, with the intention of encoding python to internal structures (no yield statements)
# this way we can write the majority of the core code in python

import os, re
from base64 import b64decode


def clean_name(NAME):
	for token in ('.','/','\\',' '): # TODO use 'is alphanumeric or underscore', else underscore
		NAME = NAME.replace(token, '_')
	return NAME


	
def walk_tree(NODE):

	#if NODE.get('__type__') != 'module':
	#	print('warning: toplevel node is not a module?', repr(NODE.get('__type__')))

	QUEUE = [[NODE]]
	while QUEUE:

		PATH = QUEUE.pop(0)
		#SRC_NODE = NODE['__src__']

		yield PATH

		NODE = PATH[-1]
		if NODE is None:
			continue

		#if 'body' in NODE and TYPE not in ('class_definition',):
		#	NODE['locals'] = {} # has own local namespace XXX this would be creating new sub ENV


		# ENQUEUE
		for attr,value in NODE.items():
			if isinstance(value, list) and all([isinstance(d, dict) and '__type__' in d for d in value]):
				QUEUE.extend([PATH + [n] for n in value])
			elif isinstance(value, dict) and '__type__' in value:
				QUEUE.append(PATH + [value])

def build(ENV):

	class SnapInternalCompiler(object):

		__slots__ = ['settings', 'imports', 'predefs']


		@property
		def indent_token(self):
			try:
				return self.settings['indent_token']
			except:
				return '\t'

		@property
		def is_headerfile(self):
			return self.settings.get('is_headerfile', False)



		@property
		def filepath(self):
			return self.settings.get('filepath', 'unknown')

		@property
		def basename(self):
			return os.path.basename(self.filepath)

		@property
		def module_name(self):
			return clean_name(self.basename)

		# TODO can we push the class to a stack?  get the classname of the current class as a property?
		def class_instance_name(self, CLASSNAME):
			# TODO find class in stack...
			return '__' + self.module_name + '_' + CLASSNAME

		def class_type_name(self, CLASSNAME):
			return self.class_instance_name(CLASSNAME) + 'Type'

		def class_predefined_name(self, CLASSNAME):
			return self.module_name + '_class_' + CLASSNAME

		def method_name(self, CLASSNAME, METHODNAME):
			return self.class_instance_name(CLASSNAME) + '_' + METHODNAME + '__mthd'



		def function_predefined_name(self, FUNCNAME):
			return self.module_name + '_' + FUNCNAME + '__func'

		def register_ENV_name(self, X):
			'' # TODO


		def set(self, **SETTINGS):


			# TODO validate
			self.settings.update(SETTINGS)

		def INDENT(self, level=0):
			# XXX TODO we add stack indent level onto self.settings indent_level (so when indent_level is assigned it is included)

			indent_level = self.settings.get('indent_level', 0)

			#idx = len(self.stack)
			#while idx > len(self.stack):
			#	idx -= 1
			#	if 'indent_level' in self.stack[idx]:
			#		indent_level = self.stack[idx]['indent_level']
			#		break

			indent_level += level
			return indent_level * self.indent_token



		def encode_moduleXXX(self, NODE):
			
			# then iterate through the definitions and yield the strings for them...

			yield '\n'

			yield '#ifndef ' + self.header_guard_name + '\n'
			yield '#define ' + self.header_guard_name + '\n'

			yield '/* This file auto-generated by {} - don\'t edit! (or changes will be lost) */\n\n'

			yield '#include "snap.h"\n\n'

			#yield 'int main(int argc, char* argv){\n\n'
			yield 'void ' + self.module_name + '_MAINBODY(SnapObject_t* ENV){\n\n'

			#for op in self['__program__']:
				# TODO this can just be the direct call of the operator function!  like GET_ITER(ENV, ARGS);?  just as a list...  we don't need to allocate memory!
				# TODO is it possible to compile a 'shared library'?  maybe just wrap each function in a c function(SnapObject* ENV, SnapObject* MSG)?
				#	-- or just always compile a shared library header and .c file, and then also a main.c and caller can decide what they want to build?  aka: do both!
			#	yield '\t' + str(op) + '(ENV, TODO:args?);\n'# TODO + args

			yield '\n'
			yield self.INDENT() + '}\n\n'

			yield '#endif /* ' + self.header_guard_name + ' */\n'

# PREPROCESS ###########################################################################################
		def preprocess(self, NODE):

			# c does not allow definitions inside of other functions, nor imports, so to
			# get around that we make sure to create all definitions in the module first,
			# and then just initialize them into the ENV in <MODULENAME>_MAINBODY(ENV) ->
			# which represents the import / run of the module

			TYPE = NODE['__type__']

			imports = self.imports
			predefs = self.predefs

			def num(T):
				return len([True for n in predefs.values() if n['__type__'] == T]) + 1

			def add_predef(PRE):
				predefs[id(PRE['__src__'])] = PRE
				PRE['count'] = len(predefs) # this is to make sure we can define them in dependency order...

			for root in walk_tree(NODE):
				N = root[-1]
				TYPE = N['__type__']
				count = len(predefs)

				pre = {'__type__':'predefine_' + TYPE, '__src__':N, 'index':num('predefine_' + TYPE)}

################ ROOT NODES:
				if TYPE == 'module': pass

				elif TYPE == 'input_expression': pass
				elif TYPE == 'interactive': pass
				elif TYPE == 'function_type': pass

################ LITERALS:
				elif TYPE == 'constant': pass

				elif TYPE == 'formatted_value': raise NotImplementedError('(v3.8+)', repr(TYPE))
				elif TYPE == 'joined_string': raise NotImplementedError('(v3.8+)', repr(TYPE))

				elif TYPE == 'list': pass
				elif TYPE == 'tuple': pass
				elif TYPE == 'set': pass
				elif TYPE == 'dictionary': pass

################ VARIABLES:
				elif TYPE == 'name': pass
				elif TYPE == 'load': pass #raise NotImplementedError(repr(TYPE))
				elif TYPE == 'store': pass #raise NotImplementedError(repr(TYPE))
				elif TYPE == 'remove': pass #raise NotImplementedError(repr(TYPE))

				elif TYPE == 'starred': pass

################ EXPRESSIONS:
				elif TYPE == 'expression': pass
				elif TYPE == 'unary_operation': pass

				elif TYPE == 'unary_add': pass
				elif TYPE == 'unary_subtract': pass
				elif TYPE == 'not': pass
				elif TYPE == 'bitwise_invert': pass

				elif TYPE == 'binary_operation': pass

				elif TYPE == 'add': pass
				elif TYPE == 'subtract': pass
				elif TYPE == 'multiply': pass
				elif TYPE == 'divide': pass
				elif TYPE == 'floor_divide': pass
				elif TYPE == 'modulo': pass
				elif TYPE == 'power': pass
				elif TYPE == 'bitwise_left_shift': pass
				elif TYPE == 'bitwise_right_shift': pass
				elif TYPE == 'bitwise_or': pass
				elif TYPE == 'bitwise_xor': pass
				elif TYPE == 'bitwise_and': pass
				elif TYPE == 'matrix_multiply': raise NotImplementedError(repr(TYPE))

				elif TYPE == 'bool_operation':
					if len(N['values']) > 2:
						add_predef(pre)
						pre['predefined_name'] = self.module_name + '_bool_op' + str(pre['index'])

				elif TYPE == 'and': pass
				elif TYPE == 'or': pass

				elif TYPE == 'comparison':
					if len(N['operators']) > 1:
						add_predef(pre)
						pre['predefined_name'] = self.module_name + '_compare' + str(pre['index'])

				elif TYPE == 'equal': pass
				elif TYPE == 'not_equal': pass
				elif TYPE == 'less_than': pass
				elif TYPE == 'less_or_equal': pass
				elif TYPE == 'greater_than': pass
				elif TYPE == 'greater_or_equal': pass
				elif TYPE == 'is': pass
				elif TYPE == 'is_not': pass
				elif TYPE == 'in': pass
				elif TYPE == 'not_in': pass

				elif TYPE == 'call': pass

				elif TYPE == 'keyword': pass
				elif TYPE == 'if_expression': pass
				elif TYPE == 'attribute': pass

				elif TYPE == 'named_expression': raise NotImplementedError('(v3.8+)', repr(TYPE))

################ SUBSCRIPTING:
				elif TYPE == 'subscript': pass
				elif TYPE == 'slice': pass

################ COMPREHENSIONS: # TODO these will need to generate custom functions to define them
				elif TYPE == 'list_comprehension':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_list_comp' + str(pre['index'])
				elif TYPE == 'set_comprehension':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_set_comp' + str(pre['index'])
				elif TYPE == 'generator_comprehension':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_gen_comp' + str(pre['index'])
				elif TYPE == 'dictionary_comprehension':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_dict_comp' + str(pre['index'])
				elif TYPE == 'comprehension':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_comp' + str(pre['index'])

################ STATEMENTS:
				elif TYPE == 'assign': pass
				elif TYPE == 'annotated_assign': raise NotImplementedError('(v3.8+)', repr(TYPE))
				elif TYPE == 'augmented_assign': pass
				elif TYPE == 'raise': pass
				elif TYPE == 'assert': pass
				elif TYPE == 'delete': pass
				elif TYPE == 'pass': pass
				elif TYPE == 'type_alias': NotImplementedError('(v3.8+)', repr(TYPE))

################ IMPORTS: # TODO?
				elif TYPE == 'import': pass
				elif TYPE == 'import_from': pass
				elif TYPE == 'import_alias': pass

################ CONTROL FLOW:
				elif TYPE == 'if': pass
				elif TYPE == 'for': pass
				elif TYPE == 'while': pass
				elif TYPE == 'break': pass
				elif TYPE == 'continue': pass

				# XXX context managers can't work because we have to return to them which can only be done with stack...
				elif TYPE == 'try': #raise NotImplementedError(repr(TYPE), 'forbidden')
					'' # TODO just define the try body in a function, and then check if ENV exception and if so then attempt to handle it (exception can be in main code section)
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_try' + str(pre['index'])
				elif TYPE == 'try_star': pass #raise NotImplementedError('(v3.11+)', repr(TYPE), 'forbidden')
				elif TYPE == 'exception': pass #raise NotImplementedError(repr(TYPE), 'forbidden')
				elif TYPE == 'with': pass #raise NotImplementedError(repr(TYPE), 'forbidden')
				elif TYPE == 'with_item': pass #raise NotImplementedError(repr(TYPE), 'forbidden')

################ PATTERN MATCHING: TODO v3.8+

################ TYPE ANNOTATIONS: TODO v3.8+

################ TYPE PARAMETERS: TODO v3.8+

################ FUNCTION AND CLASS DEFINITIONS:
				elif TYPE == 'function_definition':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_func_' + N['name']

				elif TYPE == 'lambda':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_lambda' + str(pre['index'])

				elif TYPE == 'arguments': pass
				elif TYPE == 'argument': pass
				elif TYPE == 'return': pass

				elif TYPE == 'yield': raise NotImplementedError(repr(TYPE), 'forbidden')
				elif TYPE == 'yield_from': raise NotImplementedError(repr(TYPE), 'forbidden')

				elif TYPE == 'global': pass
				elif TYPE == 'non_local': pass

				elif TYPE == 'class_definition':
					add_predef(pre)
					pre['predefined_name'] = self.module_name + '_class_' + N['name']
					pre['predefined_type_name'] = self.module_name + '_type_' + N['name']

					# TODO predefine methods as well...


				elif TYPE == 'newline': pass

				else:
					raise NotImplementedError('no predefinition for', repr(TYPE))


		def fully_encode(self, NODE, sub_indent_level=0):
			s = self.settings
			indent_before = s['indent_level']
			s['indent_level'] = indent_before + sub_indent_level
			_return = ''.join(list(self.encode_element(NODE)))
			s['indent_level'] = indent_before
			return _return

######## ENCODE ##########################################################################################################
		def encode_element(self, NODE):
			# https://docs.python.org/3/library/ast.html
			# input is ast json output from python decoder

			TYPE = NODE['__type__']

############ ROOT NODES:
			if TYPE == 'module': # TODO
				''#list of predefinitions (classes, functions, lambda, yield, imports, ...) - everything that needs to be declared at the top of the module
				yield '\n'

				# NOTE: imports/include statements and header guards will be handled externally to this module
				predefs = self.predefs

				#has_index = list(sorted([n for n in predefs.values() if 'index' in n], key=lambda x: -x['index']))
				#no_index = [n for n in predefs.values() if n not in has_index]

				for n in sorted(predefs.values(), key=lambda x: -x['count']):

					yield self.fully_encode(n)

					yield '\n'

				yield self.INDENT() + 'void ' + self.module_name + '__MAINBODY(SnapObject_t* ENV)'
				if self.is_headerfile:
					yield ';\n'
				else:
					yield '{\n\n'

					for sub in NODE['body']:
						yield self.fully_encode(sub, sub_indent_level=1)
						yield '\n'

					yield '\n'
			
					yield self.INDENT() + '}\n'

			elif TYPE == 'input_expression': raise NotImplementedError(repr(TYPE))
			elif TYPE == 'interactive': raise NotImplementedError(repr(TYPE))
			elif TYPE == 'function_type': raise NotImplementedError(repr(TYPE))

############ LITERALS:
			elif TYPE == 'constant':

				value = NODE['value']

				data_type = NODE['data_type']

				if data_type == 'string':
					if value.startswith('snapc:'):
						# implement as c code, as is, but fix indent
						lines = value[len('snapc:'):].split('\n')
						indent_pattern = re.compile(r"(\s+)")
						smallest_indent = None
						for line in lines:
							match = indent_pattern.match(line)
							if match and (smallest_indent is None or len(match.group(1)) > len(smallest_indent)):
								smallest_indent = match.group(1)

						for line in lines:
							if line.startswith(smallest_indent):
								line = line[len(smallest_indent):]
							yield self.INDENT() + line + '\n'

					else:
						yield self.INDENT() + '_str("' + repr(''.join(['\\'+c if c == '"' else c for c in value]))[1:-1] + '")' # TODO independent lines...?
				elif data_type == 'bytes':
					value = b64decode(value) # TODO how to represent bytes in c?  char?
					yield self.INDENT() + '_bytes("' + repr(value)[2:-1] + '", ' + str(len(value)) + ')'
				elif data_type == 'integer':
					# bool isn't the right type??
					text = str(value)
					if text in ('True', 'False'): raise NotImplementedError('fix bool in ast') # TODO
					#if text == 'True':
					#	yield self.INDENT() + '_bool(1)'
					#elif text == 'False':
					#	yield self.INDENT() + '_bool(0)'
					#else:				
					#	yield self.INDENT() + '_int(' + str(value) + ')'
					yield self.INDENT() + '_int(' + str(value) + ')'
				elif data_type == 'floating_point':
					yield self.INDENT() + '_float(' + str(value) + ')'
				elif data_type == 'complex':
					raise NotImplementedError('complex numbers not yet mapped', repr(value))
				elif data_type == 'boolean':
					yield self.INDENT() + '_bool(' + str(int(value)) + ')'
				elif data_type == 'null':
					assert value is None
					yield self.INDENT() + 'NULL' # ?
				elif data_type == 'ellipsis':
					raise NotImplementedError("ellipsis is deprecated; current ast.parse doesn't even allow it.")
				else:
					raise NotImplementedError('constant type', type(value))

			elif TYPE == 'formatted_value': raise NotImplementedError('(v3.8+)', repr(TYPE))
			elif TYPE == 'joined_string': raise NotImplementedError('(v3.8+)', repr(TYPE))

			elif TYPE in ('list', 'tuple', 'set'):
				items = NODE['items']
				if items:
					#'_call(_get(ENV, "' + TYPE + '"), _msg())'
					item_list = ', '.join([self.fully_encode(item) for item in items])
					item_list = '_a' + str(len(items)) + '(' + item_list + ')'
					msg = '_msg_a(' + item_list + ')'
				else:
					msg = 'NULL'
				yield self.INDENT() + '_' + TYPE + '(' + msg + ')'

			elif TYPE == 'dictionary':

				msg_name = '_msg'

				using_arguments = [['a',None], ['A',None], ['k',None], ['K',None]]

				kwargs = []
				unpack_kwargs = None
				for k,v in zip(NODE['keys'], NODE['values']):
					if k is None or k['__type__'] == 'NoneType':
						# if key is None then value is name of the dict to unpack (ie. {'a':1, **x})
						assert unpack_kwargs is None, 'duplicate for unpack_kwargs'
						unpack_kwargs = self.fully_encode(v)
					else:
						kwargs.extend( (self.fully_encode(k), self.fully_encode(v)) )

				if kwargs:
					using_arguments[2][1] = '_k' + str(len(kwargs) // 2) + '(' + ', '.join(kwargs) + ')'

				if unpack_kwargs:
					using_arguments[3][1] = unpack_kwargs

				using_arguments = [e for e in using_arguments if e[1] is not None]

				if using_arguments:
					msg_name += '_' + ''.join([e[0] for e in using_arguments])
					using = ', '.join([e[1] for e in using_arguments])
					msg = msg_name + '(' + using + ')'
				else:
					msg = 'NULL'

				yield self.INDENT() + '_dict(' + msg + ')'

############ VARIABLES:
			elif TYPE == 'name':
				name = NODE['value']
				context = NODE['context']['__type__']
				"""
				if context == 'load':
					yield CTX.INDENT() + '_get(ENV, _str("' + name + '"))'
				elif context == 'store':
					# TODO this would need to have the value to assign...
					#yield CTX.INDENT() + '_set(ENV, _str("' + name + '"))'
					yield CTX.INDENT() + '_str("' + name + '")'
				elif context == 'remove':
					#yield CTX.INDENT() + '_del(ENV, _str("' + name + '"))'
					yield CTX.INDENT() + '_str("' + name + '")'
				else:
					raise NameError('unknown context', repr(context))
				"""
				# this prevents us from having to consider the context until evaluation (so set,get,del get the same argument: _attr)
				yield self.INDENT() + '_attr(ENV, "' + name + '")'
			elif TYPE == 'load': raise NotImplementedError(repr(TYPE))
			elif TYPE == 'store': raise NotImplementedError(repr(TYPE))
			elif TYPE == 'remove': raise NotImplementedError(repr(TYPE))
			elif TYPE == 'starred': # TODO?
				#print('starred', NODE.keys())
				# _item(_slice(NULL, NULL, NULL))
				yield self.INDENT() + '_iter(' + self.fully_encode(NODE['value']) + ')'

############ EXPRESSIONS:
			elif TYPE == 'expression': # TODO?  probably just a passthrough
				# https://docs.python.org/3/library/ast.html#ast.Expr
				# this is used when return value isn't used or stored; statement by itself

				#if NODE['value']['__type__'] == 'call' and NODE['value']['base']['__type__'] == 'name' and NODE['value']['base']['value'] == 'snap_raw':
				#	args = NODE['value']['arguments']
				#	assert len(args) == 1 and args[0]['__type__'] == 'constant' and isinstance(args[0]['value'], str), 'snap_raw must be given single string argument'
				#	yield self.INDENT() + args[0]['value'] + ';'
				#else:
				yield self.INDENT() + '_DISCARD(' + self.fully_encode(NODE['value']) + ');'

			elif TYPE == 'unary_operation':
				op_name = self.fully_encode(NODE['operator'])
				yield self.INDENT() + op_name + '(' + self.fully_encode(NODE['operand']) + ')'

			elif TYPE == 'unary_add':
				#yield '_str("+")'
				yield '_uadd'
			elif TYPE == 'unary_subtract':
				#yield '_str("-")'
				yield '_usub'
			elif TYPE == 'not':
				#yield '_str("not")'
				yield '_unot'
			elif TYPE == 'bitwise_invert':
				#yield '_str("~")'
				yield '_uinv'

			elif TYPE == 'binary_operation':
				op_name = self.fully_encode(NODE['operator']) + '_op'
				left = self.fully_encode(NODE['left'])
				right = self.fully_encode(NODE['right'])
				yield self.INDENT() + op_name + '(' + left + ', ' + right + ')'
				#yield self.INDENT() + op_name + '(' + left + ', ' + right + ')'

			elif TYPE == 'add':
				#yield '_str("+")'
				yield '_add'
			elif TYPE == 'subtract':
				#yield '_str("-")'
				yield '_sub'
			elif TYPE == 'multiply':
				#yield '_str("*")'
				yield '_mul'
			elif TYPE == 'divide':
				#yield '_str("/")'
				yield '_div'
			elif TYPE == 'floor_divide':
				#yield '_str("//")'
				yield '_fldiv'
			elif TYPE == 'modulo':
				#yield '_str("%")'
				yield '_mod'
			elif TYPE == 'power':
				#yield '_str("**")'
				yield '_pow'
			elif TYPE == 'bitwise_left_shift':
				#yield '_str("<<")'
				yield '_lbit_shift'
			elif TYPE == 'bitwise_right_shift':
				#yield '_str(">>")'
				yield '_rbit_shift'
			elif TYPE == 'bitwise_or':
				#yield '_str("|")'
				yield '_bit_or'
			elif TYPE == 'bitwise_xor':
				#yield '_str("^")'
				yield '_bit_xor'
			elif TYPE == 'bitwise_and':
				#yield '_str("&")'
				yield '_bit_and'
			elif TYPE == 'matrix_multiply':
				raise NotImplementedError(TYPE)
			elif TYPE == 'bool_operation':

				if len(NODE['values']) == 2:
					op_name = self.fully_encode(NODE['operator']) + '_op'
					left = self.fully_encode(NODE['values'][0])
					right = self.fully_encode(NODE['values'][1])
					yield self.INDENT() + op_name + '(' + left + ', ' + right + ')'
				else:
					assert len(NODE['values']) > 2
					predef = self.predefs[id(NODE)]
					yield self.INDENT() + predef['predefined_name'] + '(ENV)'

			elif TYPE == 'and':
				#yield '_str("and")'
				yield '_and'
			elif TYPE == 'or':
				#yield '_str("or")'
				yield '_or'
			elif TYPE == 'comparison':
				
				if len(NODE['operators']) == 1:
					# operands includes 'left', so it's len 1 for 2 elements
					assert len(NODE['operators']) == 1 and len(NODE['values']) == 1
					op_name = self.fully_encode(NODE['operators'][0]) + '_op'
					left = self.fully_encode(NODE['left'])
					right = self.fully_encode(NODE['values'][0])
					yield self.INDENT() + op_name + '(' + left + ', ' + right + ')'
				else:
					# multiple chained comparisons will be handled by custom predefined function, we just need to call it
					assert len(NODE['values']) > 1
					predef = self.predefs[id(NODE)]
					yield self.INDENT() + predef['predefined_name'] + '(ENV)'

			elif TYPE == 'equal':
				#yield '_str("==")'
				yield '_equal'
			elif TYPE == 'not_equal':
				#yield '_str("!=")'
				yield '_not_equal'
			elif TYPE == 'less_than':
				#yield '_str("<")'
				yield '_less_than'
			elif TYPE == 'less_or_equal':
				#yield '_str("<=")'
				yield '_less_or_equal'
			elif TYPE == 'greater_than':
				#yield '_str(">")'
				yield '_greater_than'
			elif TYPE == 'greater_or_equal':
				#yield '_str(">=")'
				yield '_greater_or_equal'
			elif TYPE == 'is':
				#yield '_str("is")'
				yield '_is'
			elif TYPE == 'is_not':
				#yield '_str("is not")'
				yield '_is_not'
			elif TYPE == 'in':
				#yield '_str("in")'
				yield '_in'
			elif TYPE == 'not_in':
				#yield '_str("not in")'
				yield '_not_in'

			elif TYPE == 'call': # TODO

				#self.push(NODE, indent_level=0)

				base = NODE['base']

				# XXX instead of raw just use standalone strings that start with "snapc:..." or something
				#if base['__type__'] == 'name' and base['value'] == 'snap_raw':
				#	#name = base['value']
				#	#if name == 'snap_raw':
				#	raise Exception('snap_raw needs to be handled in expression (it must be a standalone statement)')
				#	#else:
				#	#	#arguments = ''.join(list(encode_element(SUBROOTPATH, )))
				#	#	yield CTX.INDENT() + '_call(_get(ENV, "' + name + '"), _msg(...TODO))'
				#else:

				if NODE['arguments'] or NODE['keyword_arguments']:

					msg_name = '_msg'

					using_arguments = [['a',None], ['A',None], ['k',None], ['K',None]]
						
					#next_ctx = CTX.subcontext(indent_level=0) # XXX TODO push
					args = []
					unpack_args = None
					for arg in NODE['arguments']:
						if arg['__type__'] == 'starred':
							unpack_args = self.fully_encode(arg)
						else:
							args.append(self.fully_encode(arg))

					if args:
						using_arguments[0][1] = '_a'+str(len(args)) + '(' +  ', '.join(args) + ')'

					if unpack_args:
						using_arguments[1][1] = unpack_args

					kwargs = []
					unpack_kwargs = None
					for kwarg in NODE['keyword_arguments']:
						if kwarg['key'] is None:
							unpack_kwargs = self.fully_encode(kwarg['value'])
						else:
							#print('kwarg', kwarg)
							kwargs.append(self.fully_encode(kwarg))

					if kwargs:
						using_arguments[2][1] = '_k' + str(len(kwargs)) + '(' + ', '.join(kwargs) + ')'

					if unpack_kwargs:
						using_arguments[3][1] = unpack_kwargs

					using_arguments = [e for e in using_arguments if e[1] is not None]

					if using_arguments:
						msg_name += '_' + ''.join([e[0] for e in using_arguments])
						using = ', '.join([e[1] for e in using_arguments])
						msg = msg_name + '(' + using + ')'
					else:
						msg = '_msg()'
				else:
					msg = 'NULL'

				base_element = self.fully_encode(base)
				
				yield self.INDENT() + '_call(' + base_element + ', ' + msg + ')'

				#self.pop()

			elif TYPE == 'keyword':
				key = '_str("' + NODE['key'] + '")'
				value = self.fully_encode(NODE['value'])
				yield self.INDENT() + key + ', ' + value

			elif TYPE == 'if_expression': # TODO
				#* create a c function call to represent the body of each section
				#	** unpack single else: if into else if at same level...
				raise NotImplementedError(repr(TYPE))
				yield self.INDENT() + '(if (...){} else {})' # TODO just use c if else and (else if)

			elif TYPE == 'attribute':
				#print('attribute value', NODE['value'])
				base = self.fully_encode(NODE['value'])
				attr = NODE['attribute']
				if 0:#NODE['value']['__type__'] == 'name':
					# first access if from ENV
					base_stmt = '_attr(ENV, ' + base + ')'
				else:
					# all other accesses are from whatever the previous base return was
					base_stmt = base
				yield '_attr(' + base_stmt + ', _str("' + attr + '"))'

			elif TYPE == 'named_expression': raise NotImplementedError('(v3.8+)', repr(TYPE))

############ SUBSCRIPTING:
			elif TYPE == 'subscript': # TODO
				# call(ENV, INSTANCE, "__getitem__", ARGS[0] = SnapSlice()) ?
				target = self.fully_encode(NODE['base'])
				key = self.fully_encode(NODE['key'])
				# TODO slice can assign, get, or delete...
				
				# TODO item is object, and we can use __setitem__ or other assignment to set/get?  like item = x or item.x or item['x']?  and it forwards to the request to the target...
				# XXX NOTE: _item is specifically __getitem__|__setitem__, _attr is __setattr__|__getattr__
				yield self.INDENT() + '_item(' + target + ', ' + key + ')'

			elif TYPE == 'slice':
				keys = []
				for attr in ('start','end','step'):
					x = NODE[attr]
					if x is None:
						keys.append('NULL')
					else:
						# NOTE: any type can be used as slice param
						keys.append(self.fully_encode(x))
				keys = ', '.join(keys)
				yield self.INDENT() + '_slice(' + keys + ')'

############ COMPREHENSIONS:
			elif TYPE in (
				'list_comprehension',
				'set_comprehension',
				'generator_comprehension',
				'dictionary_comprehension',
				'comprehension',
				):
				yield self.INDENT() + self.predefs[id(NODE)]['predefined_name'] + '(ENV)'

############ STATEMENTS:
			elif TYPE == 'assign':
				for sub in NODE['targets']:
					for root in walk_tree(sub): # TODO only check NODE['targets']
						if root[-1]['__type__'] == 'name':
							# for from import, need to know global names # TODO only if body is toplevel?
							self.register_ENV_name(root[-1]['value'])

				#print('targets', [n['__type__'] for n in NODE['targets']])
				len_targets = len(NODE['targets'])
				targets = ', '.join([self.fully_encode(e) for e in NODE['targets']])
				value = self.fully_encode(NODE['value'])
				# TODO multiple targets need to be merged, but how to know they are multiple and not unpacked?  make separate _assign_multi?
				if len_targets > 1:
					targets = '_a' + str(len_targets) + '(' + targets + ')'
				yield self.INDENT() + '_assign(' + targets + ', ' + value + ');'
				#-- value is SnapObject

			elif TYPE == 'annotated_assign': raise NotImplementedError('(v3.8+)', repr(TYPE))

			elif TYPE == 'augmented_assign':
				target = NODE['target']
				assert target['__type__'] == 'name', 'only names supported for augassign right now {}'.format(target['__type__'])
				name = target['value']
				op = self.fully_encode(NODE['operator'])
				value = self.fully_encode(NODE['value'])
				# TODO op?  use as string?
				yield self.INDENT() + '_augassign(_attr(ENV, _str("' + name + '")), ' + op + ', ' + value + ')'

			elif TYPE == 'raise':
				assert NODE['from'] is None, 'unsupported from argument in raise'
				exception = self.fully_encode(NODE['exception'])
				yield self.INDENT() + '_RAISE(' + exception + ', NULL);\n' # EXCEPTION, LINEINFO

			elif TYPE == 'assert': # TODO
				test = self.fully_encode(NODE['test'])
				message = NODE['message']
				if message:
					assert message['__type__'] == 'constant' and isinstance(message['value'], str), 'assertion with non-string {}'.format(type(message['value']))
					message = '"'+''.join(['\\'+c if c == '"' else c for c in message['value']])+'"'
				else:
					message = 'NULL'
				# how about when we're inside a try block?  then we're inside a function for the try...  so we can call the finally clause...
				yield self.INDENT() + 'if (_as_bool(' + test + ')){return __RAISE(ENV, "AssertionError", ' + message + ');\n' #if test(...): raise(...) # message

			elif TYPE == 'delete': # TODO
				targets = NODE['targets']
				if len(targets) == 1:
					yield self.INDENT() + '_del(ENV, ' + self.fully_encode(targets[0]) + ')'
				elif len(targets) > 1:
					targets = [self.fully_encode(t) for t in NODE['targets']]
					args = '_a' + str(len(targets)) + '(' + ', '.join(targets) + ')'
					yield self.INDENT() + '_del_multi(ENV, ' + args + ')'# or call(ENV, INSTANCE, attr)
				else:
					raise NotImplementedError('del < 1??')

			elif TYPE == 'pass':
				# there is no pass statement in c, but we'll leave a comment to indicate the intention
				yield self.INDENT() + '/* pass */'

			elif TYPE == 'type_alias': raise NotImplementedError('(v3.8+)', repr(TYPE))

############ IMPORTS:
			elif TYPE == 'import': # TODO
				statements = []
				for alias in NODE['names']:
					# TODO if dot in name here then we import the toplevel module and bring the subs in it's namespace
					statements.append(self.INDENT() + '_import("' + alias['name'] + '");') # TODO just localize the name here?  build?
				yield '\n'.join(statements) # so no trailing '\n'
				#NOTE: this is the keyword 'import', so we need to include, otherwise we would 'build' what we need into the ENV
				#- import can appear inside functions, we need to make it global (maybe delay the build until it is accessed from ENV?)

			elif TYPE == 'import_from': # TODO
				statements = []
				module = NODE['module']
				for alias in NODE['names']:
					if alias['as']:
						statements.append(self.INDENT() + '_import_from_as("' + module + '", "' + alias['name'] + '", "' + alias['as'] + '");')
					else:
						statements.append(self.INDENT() + '_import_from("' + module + '", "' + alias['name'] + '");')
				yield '\n'.join(statements) # so we only have newlines between them but don't end on one...
				#only bring in certain names?  write header with only those names?
			elif TYPE == 'import_alias': raise NotImplementedError(repr(TYPE)) # handled by imports...

############ CONTROL FLOW:
			elif TYPE == 'if': # TODO
				# TODO if body contains single if statement, then bring it up into else if here, and use its else
				#if CTX.inline(): XXX only comprehensions do this, and they can generate their own code...
				#	# in one line
				#	yield CTX.INDENT() + 'if (test){} else {}'
				#else:
				# branch vertically

				#self.push(NODE)

				#print(NODE.keys())

				else_if = []

				# TODO contain the if statement in it's own function, like with does, so we can return from it on error...
				#	-- TODO predefine the if statement and then just call it directly here, this is the call... if_statement_1()

				yield self.INDENT() + 'if (_as_bool(' + self.fully_encode(NODE['test']) + ')){\n'
				for n in NODE['body']:
					yield self.fully_encode(n, sub_indent_level=1)
				yield self.INDENT() + '}\n'
				yield self.INDENT() + 'else {\n'
				# TODO first line of else and else if do check if test raised an error?
				yield self.INDENT(1) + '/* TODO body */\n'
				yield self.INDENT() + '}\n'

				#self.pop()

			elif TYPE == 'for': # TODO
				# TODO for else: use else variable outside loop?

				# TODO turn this into a while (1) loop?  then get next items or break/raise?

				yield self.INDENT() + '/* for TODO:info */\n' # TODO print original python line

				# TODO declare vars into ENV in case return is called from inside for loop
				yield self.INDENT() + '/* declare vars outside of loop (so we can refcount them after loop completes) */\n'

				yield self.INDENT() + 'while (1){\n'

				yield self.INDENT(1) + '/* unpack iter */\n' # TODO unpack to local var, verify, and then assign to ENV as well, refcount for the local vars...

				yield self.INDENT() + '}\n'

				"""
				while (1){
					ENV[unpack] = iter;
					if (iter complete){
						break;
					}

					body
				}

				check ENV for error after loop!
				"""

				# put inside own function like with and if statements...
				#	-- TODO predefine...

				# TODO define function then use the for statement inside of it so the keywords work...

				# TODO init the for in function, then assign start function to assign from the source to the target(s), unpack into ENV basically

			elif TYPE == 'while': # TODO
				# TODO for else: use variable outside loop
				yield 'while (test){}' # map to while statement
				#else?  then use function?  while_x_else()
				# TODO _as_bool(...) is a discard that returns an int

				# TODO
				"""
				init vars (in ENV)

				while (_as_bool(TEST)){
					body
				}

				check ENV for error
				"""

			elif TYPE == 'break':
				yield 'break;'
				#raise ValueError('this is not the way to do', repr(TYPE))
			elif TYPE == 'continue':
				yield 'continue;'
				#raise ValueError('this is not the way to do', repr(TYPE))
			elif TYPE == 'try': # TODO
				# series of functions for each branch, with error checks in ENV on return
				#make a function to handle each try/except/finally/else block, do check after call for error status
				#error status is set on ENV so check is done after call returns

				# TODO what if yield is inside try statement?  we need to pre-scan for yield, or all flow statements, and assign the next function...  partition the blocks around the keywords
				#	-- so if try contains a yield (or other flow statement) then it switches the next try state
				#	-- TODO so the main try function needs to loop on the status of the try block and keep calling the current or doing the action required...
				#	-- the yield statement means set the status of the generator of the yield value, and set the next function to the one after the yield statement...  the try blocks inside would be in the same ENV...

				predef_name = self.predefs[id(NODE)]['predefined_name']

				yield self.INDENT() + '_DISCARD(' + predef_name + '(ENV));\n'

				yield self.INDENT() + 'if (TODO:ENV.error){\n'

				for exception in NODE['exceptions']:
					yield self.INDENT(1) + '/* handle exceptions... */\n'

				# https://stackoverflow.com/questions/855759/what-is-the-intended-use-of-the-optional-else-clause-of-the-try-statement-in
				if NODE['else']:
					'/* if ENV has no exception raised run the else */'

				if NODE['finally']:
					'/* always run this */'

				yield self.INDENT() + '}\n'

				"""

				# TODO if there is a finally clause then we need to nest twice!  otherwise we could just get away with one...

				try_predef(ENV){
					try_body(ENV);
					if (ENV.exception){
						if (ENV.exception == x || ENV.exception == y || ...){
							another call? or no?
						}
					}
					else {
						if there is an else clause then include this block, no need for another function?
					}
				}
				/* finally body */ # can return here it is ok
				/* finish with error check?  report if another exception was raised... otherwise just disarm the current exception */

				"""


				#print(NODE.keys())

				#yield self.INDENT() + '_ERR_CHK(' + self.predefs[id(NODE)]['predefined_name'] + '(ENV)' + ');'

				# TODO could we add the exception to a stack?

			elif TYPE == 'try_star': # v3.11+
				raise NotImplementedError(TYPE)
			elif TYPE == 'exception':
				yield self.INDENT() + '/* TODO ' + TYPE + ' ' + str(NODE.keys()) + '*/'

			elif TYPE == 'with': # TODO
				# This is ENV[as] = expression() and then call __enter__ and __exit__() methods of the instance...
				yield 'with'
				"""
				ENV[as] = expression();
				_call(ENV[as], __enter__)
				with_call(ENV);
				_call(ENV[as], __exit__)
				"""
				#value = with_x(ENV, X)
				#value = with_x_as(ENV, X, "<as_name>") # TODO multiple names?  just list the multiple individual calls?

			elif TYPE == 'with_item':
				#raise NotImplementedError(TYPE)
				yield self.INDENT() + '/* TODO ' + TYPE + ' ' + str(NODE.keys()) + '*/'

			# PATTERN MATCHING: TODO v3.8+

			# TYPE ANNOTATIONS: TODO v3.8+

			# TYPE PARAMETERS: TODO v3.8+

			# FUNCTION AND CLASS DEFINITIONS:
			elif TYPE == 'function_definition': # TODO
				# this is just the instantiation of the function into the env in the module mainbody,
				# the definition was made at the top of the module with the other predefinitions
				name = NODE['name']
				# TODO name needs to be the name of the function defined at the top
				#predefined_name = CTX.function_predefined_name(name)
				predef_name = self.predefs[id(NODE)]['predefined_name']
				yield self.INDENT() + '_def("' + name + '", ' + predef_name + ');' # this is just instantiation of the function instance into ENV from the definition defined at the top of the module
				#- if defined inside another function it needs to be defined in module global scope (all of them do actually, we'll run the code inside ModuleName_mainbody(...)

			elif TYPE == 'lambda':
				# NOTE: _lambda returns a lambda object with the predefined function referenced (so it can then be called by the user like a function)
				name = self.predefs[id(NODE)]['predefined_name']
				yield self.INDENT() + '_lambda(' + name + ')'
				#- just make a function for it

			elif TYPE == 'arguments': # TODO
				yield self.INDENT() + 'arguments()'

			elif TYPE == 'argument': # TODO
				yield self.INDENT() + 'arg'

			elif TYPE == 'return': # TODO
				if NODE['value'] is not None:
					value = self.fully_encode(NODE['value'])
				else:
					value = 'NULL'
				yield self.INDENT() + '_RETURN(' + value + ')'
				#map as return keyword?  return using function: SnapObject = RETURN(ENV) where we indicate we go up in scope

			elif TYPE == 'yield': raise NotImplementedError(repr(TYPE), 'forbidden')
			elif TYPE == 'yield_from': raise NotImplementedError(repr(TYPE), 'forbidden')

			elif TYPE == 'global': # TODO
				#register with ENV so assignments to this go to the top ENV
				# TODO make this behave like _attr/_item where it's a proxy and will forward to the appropriate attr...  so it just finds the global env, and holds a reference to it and the attr...
				names = ['_str("' + n + '")' for n in NODE['names']]
				args = '_a' + str(len(names)) + '(' + ', '.join(names) + ')'
				yield self.INDENT() + '_global(' + args + ');'

			elif TYPE == 'non_local': # TODO
				#register with ENV so assignments to this go to the parent ENV
				# TODO behaves like _attr or _global, but finds the first parent ENV with the attr
				names = ['_str("' + n + '")' for n in NODE['names']]
				args = '_a' + str(len(names)) + '(' + ', '.join(names) + ')'
				yield self.INDENT() + '_nonlocal(' + args + ');'

			elif TYPE == 'class_definition': # TODO
				#make type and instance functions, as well as methods in global scope, instantiate by calling the type
				name = NODE['name']
				predef_name = self.predefs[id(NODE)]['predefined_name']
				yield self.INDENT() + '_class("' + name + '", ' + predef_name + ');'


			elif TYPE == 'newline':
				# TODO
				'keep track of current c newlines, and add extra newlines, or just always add newlines to try to space the statements like they were in python'
				# TODO in the python decoder add spacers based on the line info, where needed inside any node with a body...

				# TODO also include python line/function info for debugging along with the c ones...
				yield '\n'


			# PREDEFINITIONS
			elif TYPE == 'predefine_function_definition':
				# TODO decorators

				#self.push(NODE)

				SRC = NODE['__src__']
				module_name = self.module_name
				#function_name = module_name + '_' + 'func' + str(NODE['index']) + '_' + SRC['name']
				yield 'SnapObject_t* ' + NODE['predefined_name'] + '(SnapObject_t* ENV, SnapObject_t* MSG){\n'
				yield self.INDENT(1) + 'if (_ERRORED()){\n'
				yield self.INDENT(2) + '_RETURN(NULL);\n'
				yield self.INDENT(1) + '};\n'
				yield self.INDENT(1) + 'ENV = _LOCAL_ENV(ENV);\n\n' # sub env

				# TODO unpack the args into local ENV variables, and verify arguments are correct
				#	-- if 'data_type' then do isinstance() check for that datatype...

				#next_ctx = CTX.subcontext()
				for e in SRC['body']:
					enc = self.INDENT(1) + self.fully_encode(e)
					yield enc

				yield '\n'

				yield self.INDENT(1) + '_RETURN(NULL);\n'
				yield self.INDENT() + '}\n'

				#self.pop()

			elif TYPE == 'predefine_class_definition':
				# TODO decorators?
				SRC = NODE['__src__']

				# TODO define the type base class, add to env, link them by name (instance gets class from __class__ var)

				# TODO type __call__ creates new instance

				# TODO class vars assign to type in __init__?

				yield 'SnapObject_t* ' + NODE['predefined_name'] + '(SnapObject_t* ENV, SnapObject_t* MSG){\n'
				yield self.INDENT(1) + 'ENV = _LOCAL_ENV(ENV);\n\n'

				yield self.INDENT(1) + '_RETURN(NULL);\n'
				yield self.INDENT() + '}\n'

			elif TYPE == 'predefine_lambda':

				name = NODE['predefined_name']

				yield 'SnapObject* ' + name + '(SnapObject* ENV, SnapObject* MSG){\n'

				yield '\n'
				yield self.INDENT(1) + '/* TODO: verify arguments and ENV is the MSG? */\n\n' # TODO unpack MSG into local ENV
				# TODO lambda is single statement so we can just return the output of the whole statement?

				SRC = NODE['__src__']

				body = self.fully_encode(SRC['body'])

				#yield self.INDENT() + '_lambdef(' + name + ');\n'
				yield self.INDENT(1) + '_RETURN(' + body + ');\n'
				yield self.INDENT() + '};\n'

			elif TYPE == 'predefine_bool_operation':

				SRC = NODE['__src__']

				#print(SRC.keys())

				name = NODE['predefined_name']

				yield self.INDENT() + 'SnapObject* ' + name + '(SnapObject* ENV){\n\n'

				op_name = self.fully_encode(SRC['operator']) + '_op'

				#print(SRC)
				left,right = self.fully_encode(SRC['values'][0]), self.fully_encode(SRC['values'][1])
				yield self.INDENT(1) + 'SnapObject* _result = ' + op_name + '(' + left + ', ' + right + ');\n'

				idx = 2
				for value in SRC['values'][idx:]:

					yield self.INDENT(1) + 'if (_as_int(_result)){_RETURN(_result);}\n'

					left = '_result'
					right = self.fully_encode(value)

					yield self.INDENT(1) + '_result = ' + op_name + '(' + left + ', ' + right + ');\n'

				yield self.INDENT(1) + '_RETURN(_result);\n'
				yield self.INDENT() + '}\n'

			elif TYPE == 'predefine_comparison':

				SRC = NODE['__src__']

				yield self.INDENT() + 'SnapObject* ' + NODE['predefined_name'] + '(SnapObject* ENV){\n\n'

				op_name = self.fully_encode(SRC['operators'][0]) + '_op'

				left,right = self.fully_encode(SRC['left']), self.fully_encode(SRC['values'][0])

				yield self.INDENT(1) + 'SnapObject* _result = ' + op_name + '(' + left + ', ' + right + ');\n'

				idx = 1
				for value in SRC['values'][idx:]:

					yield self.INDENT(1) + 'if (_as_int(_result)){_RETURN(_result);}\n'

					op_name = self.fully_encode(SRC['operators'][idx]) + '_op'
					left = '_result'
					right = self.fully_encode(value)

					yield self.INDENT(1) + '_result = ' + op_name + '(' + left + ', ' + right + ');\n'

					idx += 1

				yield self.INDENT(1) + '_RETURN(_result);\n'

				yield self.INDENT() + '}\n'


			# COMPREHENSIONS
			elif TYPE in (
				'predefine_list_comprehension',
				'predefine_generator_comprehension',
				'predefine_set_comprehension',
				'predefine_dictionary_comprehension',
				'predefine_comprehension',
				):

				SRC = NODE['__src__']

				yield self.INDENT() + 'SnapObject_t* ' + NODE['predefined_name'] + '(SnapObject_t* ENV){\n\n'

				yield self.INDENT(1) + '/* TODO: ' + TYPE + ' ' + str(SRC.keys()) + '*/\n' # TODO

				yield self.INDENT() + '}\n'


			elif TYPE == 'predefine_try':

				SRC = NODE['__src__']

				yield self.INDENT() + 'SnapObject_t* ' + NODE['predefined_name'] + '(SnapObject_t* ENV){\n\n'

				for stmt in SRC['body']:
					yield self.INDENT(1) + self.fully_encode(stmt) + '\n'

				#yield self.INDENT(1) + '/* TODO try ' + str(SRC.keys()) + ' */\n'

				# TODO check for error and handle via exception blocks and call finally no matter what

				yield self.INDENT() + '}\n'


			elif TYPE == 'predefine_forXXX':

				SRC = NODE['__src__']

				yield 'SnapObject_t* ' + NODE['predefined_name'] + '(SnapObject_t* ENV){\n\n'

				# TODO register start and end function, on block

				# TODO start does assign of variables to ENV

				yield self.INDENT(1) + '/* TODO for ' + str(SRC.keys()) + ' */\n\n'

				yield self.INDENT() + '}\n'

			# XXX import logic will be external to this module (includes)
			elif TYPE == 'predefine_import':
				pass
			elif TYPE == 'predefine_import_from':
				pass

			else:
				raise TypeError('unknown type', repr(TYPE))


		def encode(self, JSON):
			# encodes the abstract ast (postprocessed) from python syntax (python_decoder.py) into a python-like c mapping (not directly c syntax)

			assert JSON['__type__'] == 'module', 'only module type supported right now...'

			self.reset()
			#wrapped = wrap_tree(JSON)
			self.preprocess(JSON)
			for s in self.encode_element(JSON):
				yield s

		def reset(self):

			self.settings['indent_level'] = 0
			self.imports = []
			#self.stack = []
			self.predefs = {}



		def __init__(self, **SETTINGS):

			self.settings = {
				'indent_level':0,
				'indent_token':'\t',
			}
			self.imports = [] # so we can see the list of imports after
			self.predefs = {} # {id():dict(), ...}

			if SETTINGS:
				self.set(**SETTINGS)

	ENV.SnapInternalCompiler = SnapInternalCompiler


def main(ENV):

	THISDIR = os.path.realpath(os.path.dirname(__file__))
	TESTFILE = os.path.join(THISDIR, 'include/snap/types/SnapEnv.py')

	if not getattr(ENV, 'SnapInternalCompiler', None):
		build(ENV)

	c = ENV.SnapInternalCompiler()

	with open(TESTFILE, 'r') as openfile:
		j = ENV.LANGUAGE.python.decode(openfile.read())

	c.settings['filepath'] = TESTFILE # TODO nicer...
	for text in c.encode(j):
		print(text, end='')


if __name__ == '__main__':

	from snap.SnapEnv import SnapEnv
	main(SnapEnv())

