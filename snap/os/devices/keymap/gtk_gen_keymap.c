
#include <gtk/gtk.h>
#include <libgen.h> // dirname

char* new_string(int SIZE){
	char* s = (char*)malloc(SIZE);
	memset(s, 0, SIZE);
	return s;
}

#define strfmt(FMT, ...)({\
	char* string = NULL;\
	int required_length = snprintf(NULL, 0, FMT, ##__VA_ARGS__);\
	if (required_length < 0){\
		fprintf(stdout, "unable to format string!");\
	}\
	else if (required_length > 0){\
		string = (char*)malloc(required_length + 1);\
		if (!string){\
			fprintf(stdout, "unable to allocate string buffer!");\
		}\
		else {\
			snprintf(string, required_length + 1, FMT, ##__VA_ARGS__);\
		}\
	}\
	string;\
})

int string_startswith(const char* A, const char* B){

	if (A && B){

		int length_B = strlen(B);

		if (length_B > 0 && length_B <= strlen(A)){
			return (memcmp(A, B, length_B * sizeof (char)) == 0);
		}
	}
	return 0;
}


void print_gtk_info(FILE* openfile){

	gtk_init(NULL, NULL);

	// https://developer.gnome.org/gdk3/stable/gdk3-Keyboard-Handling.html
	// https://developer.gnome.org/gdk2/stable/gdk2-Keyboard-Handling.html

	// https://developer.gnome.org/gdk2/stable/gdk2-Keyboard-Handling.html#gdk-keymap-translate-keyboard-state
	GdkDisplay* display = gdk_display_get_default();
	//GdkKeymap* keymap = gdk_keymap_get_default(); // or gdk_keymap_get_for_display()?
	GdkKeymap* keymap = gdk_keymap_get_for_display(display);

	//fprintf(stdout, "keymap(%p) display(%p)\n", keymap, display);

	fprintf(openfile, "# this is generated by gtk in %s\nSNAP_KEYMAP = [\n", __FILE__);

	guint index = 0; // hardware_keycode
	GdkKeymapKey* keys;
	guint* keyvals;
	gint n_entries;
	while (index < 1000){ // if a keyboard uses higher than index 400 this number will need to increase, most use ~250
		if (gdk_keymap_get_entries_for_keycode(keymap, index, &keys, &keyvals, &n_entries)){
			// create input on keyboards
			//snap_warning("index %d", index);
			int entry_idx = 0;
			while (entry_idx < n_entries){

				char* gtk_keyname = (char*)gdk_keyval_name(keyvals[entry_idx]);

				if (string_startswith(gtk_keyname, "XF86")){
					//snap_warning("startswith XF86: %s", gtk_keyname);
					gtk_keyname += strlen("XF86"); // advance past it
				}

				const char* keyname = NULL; //snap_keyval_to_name((int)keyvals[entry_idx]);
				
				if (!gtk_keyname){// || !keyname){
					fprintf(stdout, "missing keyname %s %s\n", gtk_keyname, keyname);
				}
				else if (1){//snap_name_to_keyval(gtk_keyname) != keyvals[entry_idx]){

					if (1){//!((void*)keyname == (void*)"NoSymbol" && keyvals[entry_idx] == 0)){
						// NOTE: keys[entry_idx].keycode | hardware_code == index

						//snap_out("hardware_code %d keyval %d level %d group %d name %s", index, keyvals[entry_idx], entry_idx, keys[entry_idx].group, gtk_keyname);

						#if 1
						int hardware_code = keys[entry_idx].keycode;
						int keyval = keyvals[entry_idx];
						int group = keys[entry_idx].group;

						// I don't want to use wide chars, forcing string!
						char text_src[5] = "xxxx";
						char* text = NULL;
						guint get_text = gdk_keyval_to_unicode(keyval);
						if (get_text > 0){
							memcpy(text_src, &get_text, sizeof (guint));
							text = (char*)text_src;
							//snap_out("text %s", text);
						}
						else {
							//snap_out("no text %s", keyname);
						}

						//snap_event(&keyboard, "DEFINE_KEY",
						fprintf(openfile, "\t{'code':%d, 'name':'%s', 'keyval':%d, 'level':%i, 'group':%i, 'text':",
								hardware_code, gtk_keyname, keyval, entry_idx, group);

						if (text){
							// https://stackoverflow.com/questions/11601703/python-style-repr-for-char-buffer-in-c

							fprintf(openfile, "0x");

							int c = 0;
							while (c < strlen(text)){

								fprintf(openfile, "%X", text[c]);

								c++;
							}
							
							// print it
						}
						else {
							fprintf(openfile, "None");
						}
						fprintf(openfile, "},\n");
						#endif
							
							

						#if 0
						snap_warning("keyval from name: %d %s %s", snap_name_to_keyval(gtk_keyname), gtk_keyname, keyname);
			
						snap_out("[%d].[%d] code(%u)\n\tvalue(%u) name(\"%s\" \"%s\")\n\tgroup(%d) level(%d)",
							index,
							entry_idx,
							keys[entry_idx].keycode,
							keyvals[entry_idx],
							gtk_keyname,
							keyname,
							keys[entry_idx].group, // groups are not used on US (english) keyboards
							keys[entry_idx].level
							);
						#endif
					}
				}
				
				entry_idx++;
			}
			g_free(keys); g_free(keyvals);
			keys = NULL; keyvals = NULL;
		}
		index++;
	}

	fprintf(openfile, "]\n");

	// TODO modifier keys need to be done separately
	// https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#GDK-MODIFIER-MASK:CAPS
	// https://developer.gnome.org/gdk3/stable/gdk3-Windows.html#GdkModifierType
	// Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose, Apple, CapsLock or ShiftLock

	//GdkKeymapKey lookup_key = {.keycode = 0xffe1, .group=0, .level=0};
	//(void)lookup_key;

	//guint keyval = gdk_keymap_lookup_key(keymap, &lookup_key);
	//snap_out("shift_L keyval(%d)", keyval);

	/*
	SNAPLIST(modifiers,
		

	snap_event(&keyboard, "DEFINE_KEY",
		"code", &hardware_code,
		"keyval", &keyval,
		"text", NULL,
		"level", &zero,
		"group", NULL
		);
	*/

	return;
}


int main(char** argc, int argv){

	char* rp = new_string(100);
	realpath(__FILE__, rp);

	char* dn = dirname(rp);

	char* filepath = strfmt("%s/%s", dn, "gtk_gen_keymap.py");
	
	fprintf(stdout, "%s\n", filepath);

    FILE* openfile = fopen(filepath, "w");
	free(rp); free(filepath);
	rp = NULL; filepath = NULL;
	if (!openfile){
		fprintf(stdout, "unable to open file for writing\n");
		exit(-1);
	}

	print_gtk_info(openfile);


    fclose(openfile);

	return 0;
}
