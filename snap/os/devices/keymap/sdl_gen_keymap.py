
from snap.lib.extern.SDL import *

from claire import * # TODO use snap browser


from gtk_keymap import *

def find_keycodes(keyval):
	code = None
	vals = []
	for entry in SNAP_KEYBOARD_MAPPING:
		if code is not None and entry['code'] == code:
			pass

		elif entry['keyval'] == keyval:
			code = entry['code']

		else:
			continue

		vals.append(entry)

	if len(set([v['level'] for v in vals])) < 2 or len(set([v['keyval'] for v in vals])) < 2:
		vals = []

	# TODO remove entries with only one unique level, or don't have 2 levels (specifically level 1)
	return vals


SDL_Init(SDL_INIT_EVERYTHING)
"""
for scancode, name in scancodes:
	keyval = SDL_GetKeyFromScancode(scancode)
	entries = find_keycodes(keyval)
	if not entries:
		try:
			chr_val = chr(keyval)
		except:
			chr_val = None
		print(scancode, keyval, repr(chr_val), name, [(e['keyval'], e['name'], e['level']) for e in entries])
"""
# TODO shift group is true if: (SHIFTL | SHIFTR) ^ CAPSLOCK

#SNAP_KEYVALUES

B = Browser('https://wiki.libsdl.org/SDL2/SDLScancodeLookup')
tables = B.soup.findAll('table')
assert len(tables) == 1, 'tables?'

keymap = []
for table in tables:
	rows = table.findAll('tr')
	for row in rows[1:]: # skip header row
		scancode,hexidecimal,name = [p.text for p in row.findAll('p')]

		scancode = int(scancode)
		scanname = name.replace('SDL_SCANCODE_','')

		entry = {'scan':(scancode, scanname)}

		base_keycode = SDL_GetKeyFromScancode(scancode)
		base_keyname = snap_keyval_to_name(base_keycode)
		if base_keyname and base_keycode != 0:
			# text key
			base_text = chr(base_keycode)
			keys = entry['keys'] = [(base_keycode, base_keyname, base_text)]
			shift_keycode = -1
			shift_keyname = None
			shift_keyvals = [e for e in find_keycodes(base_keycode) if e['level'] == 1]
			if shift_keyvals:
				k = shift_keyvals.pop()
				shift_keycode = k['keyval']
				shift_keyname = snap_keyval_to_name(k['keyval'])
				shift_text = chr(shift_keycode)
				keys.append((shift_keycode, shift_keyname, shift_text))
				
			print('text key', entry)
		else:
			''#print('non-text key', entry)
		keymap.append(entry)

with open('SNAP_KEYMAP.py', 'w') as openfile:

	openfile.write('\n# auto-generated by {}\n\n'.format(os.path.basename(__file__)))

	openfile.write('SNAP_KEYCODES = [\n')

	for name,code in SNAP_KEYVALUES:
		openfile.write('\t("{}", {}),\n'.format(name, hex(code)))

	openfile.write('\t]\n\n')

	openfile.write("""SNAP_KEYCODES_LOOKUP = {}
for name,code in SNAP_KEYCODES:
	assert name != code, 'name == code? {} == {}'.format(repr(name), repr(code))
	if name in SNAP_KEYCODES_LOOKUP:
		''#print('duplicate', name, code, 'using', SNAP_KEYCODES_LOOKUP[name])
	elif code in SNAP_KEYCODES_LOOKUP:
		''#print('duplicate', name, code, 'using', SNAP_KEYCODES_LOOKUP[code])
	else:
		SNAP_KEYCODES_LOOKUP[name] = code
		SNAP_KEYCODES_LOOKUP[code] = name

""")

	openfile.write('SNAP_SCANCODES = [\n')
	
	for entry in keymap:
		scancode,scanname = entry['scan']
		openfile.write('\t("{}", {}),\n'.format(scanname, hex(scancode)))

	openfile.write('\t]\n\n')

	openfile.write("""SNAP_SCANCODES_LOOKUP = {}
for name,code in SNAP_SCANCODES:
	assert name != code, 'name == code? {} == {}'.format(repr(name), repr(code))
	if name in SNAP_SCANCODES_LOOKUP:
		''#print('duplicate', name, code, 'using', SNAP_SCANCODES_LOOKUP[name])
	elif code in SNAP_SCANCODES_LOOKUP:
		''#print('duplicate', name, code, 'using', SNAP_SCANCODES_LOOKUP[code])
	else:
		SNAP_SCANCODES_LOOKUP[name] = code
		SNAP_SCANCODES_LOOKUP[code] = name

""")

	openfile.write('SNAP_KEYMAP = [\n')

	for entry in keymap:
		openfile.write('\t' + str(entry) + ',\n')

	openfile.write('\t]\n\n')

	# gen user variables
	scancodes = [e['scan'] for e in keymap]
	for code,name in scancodes:
		openfile.write('SNAP_SCANCODE_{} = {}\n'.format(name, code))
	openfile.write('\n')

	keycodes = sorted([key[:2] for e in keymap for key in e.get('keys',[])])
	keys = []
	for key in keycodes:
		if key[0] not in [k[0] for k in keys]:
			keys.append(key)
	keycodes=keys
	for code,name in keycodes:
		openfile.write('SNAP_KEYCODE_{} = {}\n'.format(name, code))
	openfile.write('\n')

	openfile.write("""
def snap_keycode_to_name(KEYCODE):
	return SNAP_KEYCODES_LOOKUP.get(KEYCODE)

def snap_name_to_keycode(NAME):
	return SNAP_KEYCODES_LOOKUP.get(NAME)

def snap_scancode_to_name(SCANCODE):
	return SNAP_SCANCODES_LOOKUP.get(SCANCODE)

def snap_name_to_scancode(NAME):
	return SNAP_SCANCODES_LOOKUP.get(NAME)

def snap_number_to_string(NUMBER):
	# https://stackoverflow.com/questions/6999737/convert-from-hex-character-to-unicode-character-in-python
	n = NUMBER
	i = 0
	b = []
	while n >> i:

		b.append(n >> i & 0xFF)

		i += 1

	return bytes(b).decode('utf8')
	""")



# so make list of all keyvals
# and list of all scancodes, with which keyvals attach to them (if any)

			
# TODO SNAP_SCANCODE_<name> = int (for all the scancodes, and add them to a list)
# TODO SNAP_KEYSYM_<name> = int (for all keyvals, use gtk list for all of them)
#	-map keysym to name and name to keysym
# TODO SNAP_KEYGROUP_SHIFT = mapping of keysyms that have shift levels

# then make the keyboard with scancode keys and assigned keysyms,
# with shift group, modifiers, and text group (which emits through keyboard as well using "TEXT" event)

