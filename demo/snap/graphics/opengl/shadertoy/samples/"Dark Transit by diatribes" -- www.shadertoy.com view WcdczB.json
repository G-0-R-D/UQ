[
	{
		"ver": "0.1",
		"info": {
			"id": "WcdczB",
			"date": "1763779348",
			"viewed": 2922,
			"name": "Dark Transit",
			"username": "diatribes",
			"description": "Dark Transit",
			"likes": 83,
			"published": 3,
			"flags": 0,
			"usePreview": 0,
			"tags": [
				"noise",
				"tunnel",
				"lowtechtunnel"
			],
			"hasliked": 0,
			"parentid": "tfcyRS",
			"parentname": "Gibson Tunnel"
		},
		"renderpass": [
			{
				"inputs": [],
				"outputs": [
					{
						"id": "4dfGRr",
						"channel": 0
					}
				],
				"code": "// low tech tunnel\n// 28 steps\n\n/*\n    @FabriceNeyret2 -40 chars (42 total, see below)\n    → 611 (from 651)!\n    \n    --\n    \n    @bug -27 chars\n    → 584 (from 611)!\n    \n    --\n    \n    @HexaPhoenix -6 chars\n    → 578 (from 584)!\n\n    --\n    \n    @GregRostami, -30 chars\n    → 548 (from 578)!\n    \n    --\n    \n    @FabriceNeyret2, -2 chars\n    → 546 (from 548)!\n        \n    ty!!   :D\n    \n*/\n\n#define V vec3\n#define P(z)     V( 12.* cos( (z)*vec2(.1,.12) ) , z)  //\n#define A(F,H,K) abs(dot( sin(F*p*K), H +p-p )) / K \n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t=iTime,s,i,d,e,\n          T = t*4. + 5. + 5.*sin(t*.3);\n    V  c,r = iResolution;\n\n    u = ( u - r.xy/2. ) / r.y;            // scaled coords\n    if (abs(u.y) < .37)                   // cinema bars\n\n    for (V p = P(T),                      // setup ray origin, direction, and look-at\n              Z = normalize( P(T+4.) - p),\n              X = normalize(V(Z.z,0,-Z)),\n              D = V(u, 1) * mat3(-X, cross(X, Z), Z);\n\n        i++ < 28.;\n\n        c += 1./s + V(10,20,50)/max(e, .6)\n    )\n        p += D * s,                       // march\n        X = P(p.z),                       // get path\n        t = sin(t),                       // store sine of iTime (not T)\n        e = length(p - V(                 // orb (sphere with xyz offset by t)\n                   X.x,\n                   X.y + t,\n                   6.+T + t)-t)-.01,\n        s = cos(p.z*.6)*2.+ 4.            // tunnel with modulating radius\n          - min( length(p.xy - X.x - 6.)\n               , length((p-X).xy) )\n          + A(  4., .25, .1)              // noise, large scoops\n          + A(T+8., .22, 2.),             // noise, detail texture \n                                          // (remove \"T+\" if you don't like the texture moving)\n        d += s = min(e,.01+.3*abs(s));    // accumulate distance\n\n    o.rgb = c*c/1e6;                      // adjust brightness and saturation\n}\n/*\n#define V vec3\n#define P(z)     V( 12.* cos( (z)*vec2(.1,.12) ) , z)  //\n#define A(F,H,K) abs(dot( sin(F*p*K), H +p-p )) / K \n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t=iTime,s,i,d,e,\n          T = t*4. + 5. + 5.*sin(t*.3);\n    V  c,r = iResolution;\n\n    u = ( u - r.xy/2. ) / r.y;            // scaled coords\n    if (abs(u.y) < .37)                   // cinema bars\n\n    for (V p = P(T),                      // setup ray origin, direction, and look-at\n              Z = normalize( P(T+4.) - p),\n              X = normalize(V(Z.z,0,-Z)),\n              D = V(u, 1) * mat3(-X, cross(X, Z), Z);\n\n        i++ < 28.;\n\n        c += 1./s + V(10,20,50)/max(e, .6)\n    )\n        p += D * s,                       // march\n        X = P(p.z),                       // get path\n        t = sin(t),                       // store sine of iTime (not T)\n        e = length(p - V(                 // orb (sphere with xyz offset by t)\n                   X.x,\n                   X.y + t,\n                   6.+T + t)-t)-.01,\n        s = cos(p.z*.6)*2.+ 4.            // tunnel with modulating radius\n          - min( length(p.xy - X.x - 6.)\n               , length((p-X).xy) )\n          + A(  4., .25, .1)              // noise, large scoops\n          + A(T+8., .22, 2.),             // noise, detail texture \n                                          // (remove \"T+\" if you don't like the texture moving)\n        d += s = min(e,.01+.3*abs(s));    // accumulate distance\n\n    o.rgb = c*c/1e6;                      // adjust brightness and saturation\n}\n*/\n\n\n/*\n#define V vec3\n#define T        iTime*4. + 5. + 5.*sin(iTime*.3)         //\n#define P(z)     V( 12.* cos( (z)*vec2(.1,.12) ) , z)  //\n#define A(F,H,K) abs(dot( sin(F*p*K), H +p-p )) / K \n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t,s,i,d,e;\n    V  c,r = iResolution;\n\n    u = ( u - r.xy/2. ) / r.y;            // scaled coords\n    if (abs(u.y) < .375)                  // cinema bars\n\n    for (V p = P(T),                   // setup ray origin, direction, and look-at\n              Z = normalize( P(T+4.) - p),\n              X = normalize(V(Z.z,0,-Z)),\n              D = V(u, 1) * mat3(-X, cross(X, Z), Z);\n\n        i++ < 28. && d < 3e1;\n\n        c += 1./s + V(10,20,50)/max(e, .6)\n    )\n        p += D * s,                      // march\n        X = P(p.z),                      // get path\n        t = sin(iTime),                  // store sine of iTime (not T)\n        e = length(p - V(             // orb (sphere with xyz offset by t)\n                   X.x,\n                   X.y + t,\n                   6.+T + t)-t)-.01,\n        s = cos(p.z*.6)*2.+ 4.           // tunnel with modulating radius\n          - min( length(p.xy - X.x - 6.)\n               , length((p-X).xy) )\n          + A(  4., .25, .1)             // noise, large scoops\n          + A(T+8., .22, 2.),            // noise, detail texture \n                                         // (remove \"T+\" if you don't like the texture moving)\n        d += s = min(e,.01+.3*abs(s));   // accumulate distance\n\n    o.rgb = c*c/1e6;                   // adjust brightness and saturation\n}\n*/\n\n\n\n/*\n\n#define T        iTime*4. + 5. + 5.*sin(iTime*.3)         //\n#define P(z)     vec3( 12.* cos( (z)*vec2(.1,.12) ) , z)  //\n#define A(F,H,K) abs(dot( sin(F*p*K), H +p-p )) / K \n\nvoid mainImage(out vec4 o, in vec2 u) {\n   \n    float t,s,i,d,e;\n    vec3  c,r = iResolution;\n\n    u = ( u - r.xy/2. ) / r.y;            // scaled coords\n    if (abs(u.y) > .375) { o*= i; return;}// cinema bars\n    \n    \n    vec3  p = P(T),                       // setup ray origin, direction, and look-at\n          Z = normalize( P(T+4.) - p),\n          X = normalize(vec3(Z.z,0,-Z)),\n          D = vec3(u, 1) * mat3(-X, cross(X, Z), Z);\n              \n    for(; i++ < 28. && d < 3e1 ;\n        c += 1./s + 1e1*vec3(1,2,5)/max(e, .6)\n    )\n        p += D * s,                      // march\n        X = P(p.z),                      // get path\n        t = sin(iTime),                  // store sine of iTime (not T)\n        e = length(p - vec3(             // orb (sphere with xyz offset by t)\n                    X.x + t,\n                    X.y + t*2.,\n                    6.+T + t*2.))-.01,\n        s = cos(p.z*.6)*2.+ 4.           // tunnel with modulating radius\n          - min( length(p.xy - X.x - 6.)\n               , length((p-X).xy) )\n          + A(  4., .25, .1)             // noise, large scoops\n          + A(T+8., .22, 2.),            // noise, detail texture \n                                         // (remove \"T+\" if you don't like the texture moving)\n        d += s = min(e,.01+.3*abs(s));   // accumulate distance\n          \n    o.rgb = (c*c/1e6);                   // adjust brightness and saturation\n}\n\n*/\n\n\n\n\n\n\n\n\n/*\n#define T (iTime*4.+5.+sin(iTime*.3)*5.)\n#define N normalize\n#define P(z) vec3(cos((z)*.1)* 12., \\\n                  cos((z) *  .12) * 12., (z))\n#define A(F, H, K) abs(dot(sin(F*p*K), H+p-p )) / K \n\nvoid mainImage(out vec4 o, in vec2 u) {\n   \n    float st,s,i,d,e;\n    vec3  c,r = iResolution;\n    \n    // scaled coords\n    u = (u-r.xy/2.)/r.y;\n \n     // cinema bars\n    if (abs(u.y) > .375) { o = vec4(0); return;}\n    \n    // setup ray origin, direction, and look-at\n    vec3  p = P(T),ro=p,\n          Z = N( P(T+4.) - p),\n          X = N(vec3(Z.z,0,-Z)),\n          D = vec3(u, 1) * mat3(-X, cross(X, Z), Z);\n              \n    for(;i++ < 28. && d < 3e1;\n        c += 1./s + 1e1*vec3(1,2,5)/max(e, .6)\n    )\n        // march\n        p = ro + D * d,\n        \n        // get path\n        X = P(p.z),\n        \n        // store sine of iTime (not T)\n        st = sin(iTime),\n        \n        // orb (sphere with xyz offset by st)\n        e = length(p - vec3(\n                    X.x + st,\n                    X.y + st*2.,\n                    6.+T + st*2.))-.01,\n           \n        // tunnel with modulating radius\n        s = cos(p.z*.6)*2.+ 4. - \n            min(length(p.xy - X.x - 6.),\n                length(p.xy - X.xy)),\n\n\n        // noise, large scoops\n        s += A(4., .25, .1),\n        \n        // noise, detail texture\n        // remove \"T+\" if you don't like the texture moving\n        s += A(T+8., .22, 2.),\n\n        // accumulate distance\n        d += s = min(e,.01+.3*abs(s));\n        \n    // adjust brightness and saturation,\n    o.rgb = (c*c/1e6);\n\n}\n*/",
				"name": "Image",
				"description": "",
				"type": "image"
			}
		]
	}
]
